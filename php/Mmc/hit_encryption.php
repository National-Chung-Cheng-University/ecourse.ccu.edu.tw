<?
    
//////////////////////////////////////////////////////////////////////////////
//
//  hit_encrpytion.php
//
//  Contains tools for encryption/decrpytion (3DES and PKI) and 
//  encoding/decoding (SHA1)
//
//////////////////////////////////////////////////////////////////////////////
    
 require_once("inc_common.php");
    
define("HIT_ERR_CANNOT_LOAD_ENCRYPTOR",  1500);
define("HIT_ERR_CANNOT_LOAD_ENCRYPTION_KEY", 1501);
define("HIT_ERR_ERROR_WHEN_CALLING_OPENSSL",     1502);
define("HIT_ERR_CANNOT_CREATE_TEMP_FILE", 1503);
define("HIT_ERR_UNABLE_TO_ENCRYPT", 8003);
define("HIT_ERR_UNABLE_TO_DECRYPT", 8004);


if( !defined("HIT_DEFAULT_OPENSSL_DIR"))
    define("HIT_DEFAULT_OPENSSL_DIR", dirname(__FILE__).'/openssl' );

if( !defined("HIT_DEFAULT_ENCRYPTOR_DIR"))
    define("HIT_DEFAULT_ENCRYPTOR_DIR", dirname(__FILE__).'/jnjencryptor' );

if( !defined("HIT_DEFAULT_TEMP_DIR"))
    define("HIT_DEFAULT_TEMP_DIR", '<system-default-temp>' );


class EncryptionTool
{
    var $errorMessage;
    var $platform;
    
    function EncryptionTool( $opensslInstalledDir = HIT_DEFAULT_OPENSSL_DIR, 
                             $encryptorInstalledDir = HIT_DEFAULT_ENCRYPTOR_DIR,
                             $tempDir = HIT_DEFAULT_TEMP_DIR  )
    {
        $this->errorMessage = '';


        // Automatic OS detection
	//can't not detect OS, set default OS is linux, linsy
        $this->platform = function_exists("posix_uname")? "linux" : "win32";
        // Add a slash/backslash at the end if necessary
        if( preg_match( '/[^\/]+$/', $opensslInstalledDir )){
            $opensslInstalledDir .= "/";
        }
        if( preg_match( '/[^\/]+$/', $encryptorInstalledDir )){
            $encryptorInstalledDir .= "/";
        }
        
        
        if( $this->platform == "linux" ){
            $this->opensslProg = "{$opensslInstalledDir}openssl";
            $this->encryptorProg = "{$encryptorInstalledDir}jnjencryptor";
            $this->niceCmd = "nice";
        } else {
            $this->opensslProg = "{$opensslInstalledDir}openssl.exe";
            $this->encryptorProg = "<not used in win32; COM is used>";
            $this->niceCmd = "";
        }
        
        $this->tempDir = $tempDir;
    }
    


    //--------------------------------------------------------------------
    // NAME:    opensslEnc 
    // DESC:    Call OpenSSL to do symmetric de/encryption
    // PARAM:   output [out]
    //              Decrypted message
    //          input [in]
    //              Message to be decrypted
    //          key [in]
    //              Key to encrypt/decrypt the message
    //          options [in]
    //              arguments to be passed to OpenSSL.  Note: The first 
    //              argument must be ciphername
    // RETURN:  0 if operation is success
    //--------------------------------------------------------------------
    function opensslEnc(&$output, $input, $key, $options = '-des3')
    {
        global $php_errormsg;

		$origTrackErrorsSetting = ini_set('track_errors', 1);
        $origHtmlErrorsSetting = ini_set('html_errors', 0);
		$errCode = 0;
		do {

	        $inFile = tempnam($this->tempDir, 'ein');
	        $outFile = tempnam($this->tempDir, 'eou');
	        $keyFile = tempnam($this->tempDir, 'eke');
	        
	        // put input the content to a file
	        $hFile = @fopen($inFile, "w");
	        if( !$hFile ){
	            $this->errorMessage = "Unable to create temp file in directory [$this->tempDir]; make sure the directory is writeable. (".basename(__FILE__).":".__LINE__.")";
	            $errCode = HIT_ERR_CANNOT_CREATE_TEMP_FILE;
	            break;
	        }
	        
	        fwrite($hFile, $input);
	        fclose($hFile);
	        
	        // put the encryption key / password to a file
	        $hFile = fopen($keyFile, "w");
	        fwrite($hFile, $key);
	        fclose($hFile);

	        // Call OpenSSL to do the work
	        $opensslCmd = "\"{$this->opensslProg}\" enc $options -salt -in $inFile -out $outFile -kfile $keyFile 2>&1";
	        @ exec($opensslCmd, $response, $errCode);

	        // Read output generated by OpenSSL
	        // note: supposely we can use file_get_contents function,
	        //       but it is only good for PHP >= 4.3.0 
	        // note: we read data using while loop instead of filesize()
	        //       because filesize() fails (permission error) in some system!
	        //       Stat failed for <filename> (errno=2 - No such file or directory)
	        $output = '';
	        $hFile = fopen($outFile, "r");
	        while ($data = fread($hFile, 999)) {
	            $output .= $data;        
	        }
	        fclose($hFile);
	        

	        if ($output == '' || $errCode || @$php_errormsg){
	            $this->errorMessage = 
	                "PHP Error: $php_errormsg".
	                "\nOpenSSL Error: ".@implode(' ', $response).
	                "\nError when calling OpenSSL. ".
	                "ErrCode [$errCode] ".
	                "Command [$opensslCmd] ".
	                "(".basename(__FILE__).":".__LINE__.")";
	            $errCode = HIT_ERR_ERROR_WHEN_CALLING_OPENSSL;
	            break;
	        }
		} while (RUN_ONLY_ONCE);
		
		if( !$errCode ){
	        @unlink($inFile);
	        @unlink($outFile);
	        @unlink($keyFile);
		}
		
        ini_set('track_errors', $origTrackErrorsSetting );
        ini_set('html_errors', $origHtmlErrorsSetting );
        return $errCode;
    }



    //--------------------------------------------------------------------
    // NAME:    tripleDesDescrypt 
    // DESC:    Decrypt a message that is encrypted using Triple DES 
    // PARAM:   plainText [out]
    //              Decrypted message
    //          cipher [in]
    //              Message to be decrypted
    //          desKey [in]
    //              Key to decrypt the message
    //          base64encode [in]
    //              TRUE = cipher is encoded in Base64 (not in Hex)
    // RETURN:  0 if operation is success
    //--------------------------------------------------------------------
    function tripleDesDecrypt(&$plainText, $cipher, $desKey, $base64encode=TRUE)
    {
        $options = '-des3 -d';
        $options .= $base64encode ? ' -a' : '';
        
        return $this->opensslEnc($plainText, $cipher, $desKey, $options);
    }
    

    //--------------------------------------------------------------------
    // NAME:    tripleDesEncrypt 
    // DESC:    Encrypt a message using Triple DES 
    // PARAM:   cipher [out]
    //              Encrypted message
    //          plainText [in]
    //              Message to be encrypted
    //          desKey [in]
    //              Key to encrypt the message
    //          base64encode [in]
    //              TRUE = cipher will be encoded in Base64 (not in Hex)
    // RETURN:  0 if operation is success
    //--------------------------------------------------------------------
    function tripleDesEncrypt(&$cipher, $plainText, $desKey, $base64encode=TRUE)
    {
        $options = '-des3';
        $options .= $base64encode ? ' -a' : '';
        
        return $this->opensslEnc($cipher, $plainText, $desKey, $options);
    }
    


    //--------------------------------------------------------------------
    // NAME:    pkeEncrypt 
    // DESC:    Encrypt a message using Public Key Encryption (PKE)
    // PARAM:   cipher [out]
    //              Encrypted message.  Message will be in the following format:
    //              <siteId>|<encrypted session key>|<encrypted content>
    //          plainText [in]
    //              Message to be encrypted
    //          privateKeyPath [in]
    //              Path of the (sender's) private key file
    //          publicKeyPath [in]
    //              Path of the (receipent's) public key file
    //          siteId [in]
    //              ID of the sender; this value is used by the receiver to 
    //              determine which public key it should use to decrypt the 
    //              messages; usually SiteID should be the file name of the 
    //              public key.
    //          passPhrase [in]
    //              password for opening the private key
    // RETURN:  0 if operation is success
    //--------------------------------------------------------------------
    function pkeEncrypt(&$cipher, $plainText, $privateKeyPath, $publicKeyPath, $siteId, $passPhrase)
    {
        global $php_errormsg;

        $originalSetting = ini_set('track_errors', 1);
        $cipher = '';
        $errCode = 0;

        $privateKeyAbsPath = realpath($privateKeyPath);
        $publicKeyAbsPath = realpath($publicKeyPath);

        do {
            //------------------------------------------------------
            // On Linux platform, we need to call a command-line program to do the encryption
			
            if ($this->platform == "linux"){


                // remove Return characters in the content; encryptor only supports one line input
                $oneLineInput = preg_replace("/\r|\n/", '', $plainText);

                // Put encryption command, settings (public/private key location), and data into an ASCII instruction file
                $cmd = "encrypt,$privateKeyAbsPath,$passPhrase,$publicKeyAbsPath,$siteId,$oneLineInput";
                $errorFile = tempnam($this->tempDir, 'enc-err');
                $instructionFile = tempnam($this->tempDir, 'enc-instr');
                $hFile = fopen($instructionFile, "w");
                if( !$hFile ){
                    $this->errorMessage = "Unable to create temp file in directory [$this->tempDir]; make sure the directory is write-able. (".basename(__FILE__).":".__LINE__.")";
                    return HIT_ERR_CANNOT_CREATE_TEMP_FILE;
                }
                fwrite($hFile, $cmd);
                fclose($hFile);
                
                // Give the instruction file to encryptor
                
                $rtn = exec("{$this->niceCmd} \"{$this->encryptorProg}\" 2>$errorFile <$instructionFile", $response, $errCode);

                $hFile = fopen($errorFile, "r");
                $errMsg = "";
                while ($data = fread($hFile, 999)) {
                    $errMsg .= $data;        
                }
                fclose($hFile);
                    
                unlink($instructionFile);
                unlink($errorFile);

                // Parse the output from encryptor
                $cipher = trim(implode(" ", $response));

                // Check for error
                if (!$cipher || $errMsg){

                    if (! file_exists($this->encryptorProg)){
                        $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTOR;
                        $this->errorMessage = 
                            "Unable to locate jnjencryptor at [".HIT_LINUX_HMTG_ENCRYPTOR_PATH."] ".
                            "(".basename(__FILE__).":".__LINE__.")";
                        break;
                    }
                    
                    if (! is_executable($this->encryptorProg)){
                        $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTOR;
                        $this->errorMessage = 
                            "Unable to execute jnjencryptor at [$this->encryptorProg]. ".
                            "Error [$errMsg] ".
                            "Use 'chmod guo+rx' command to change file permission mode. ".
                            "(".basename(__FILE__).":".__LINE__.")";
                        break;
                    }
                    
                    if (! is_readable($privateKeyAbsPath) || ! is_readable($publicKeyAbsPath)){
                        $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTION_KEY;
                        $this->errorMessage = 
                            "Unable to load encryption keys. ".
                            "Error [$errMsg] ".
                            "Private key [$privateKeyPath] ".
                            "Public key [$publicKeyPath] ".
                            "(".basename(__FILE__).":".__LINE__.")";
                        break;
                    }

                    $errCode = HIT_ERR_UNABLE_TO_ENCRYPT;
                    $this->errorMessage = "Unable to encrypt data. [$errMsg] (".basename(__FILE__).":".__LINE__.")";
                    break;
                }
               
                $errCode = 0;
                break;
            }

            //------------------------------------------------------
            // On Windows platform, we call COM to do the encryption

            // Make sure the COM component is installed
			
            $jnjCom = NULL;
			$jnjCom = @ new COM("Hmtg.JnjEncryptor", NULL, CP_UTF8);
			
            if (is_null($jnjCom)){
                $errMsg = strip_tags($php_errormsg);
                $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTOR;
                $this->errorMessage = 
                    "Unable to load Hmtg.JnjEnecryptor COM object. ".
                    "Error [$errMsg] ".
                    "Use regsvr32 to register the COM object. ".
                    "(".basename(__FILE__).":".__LINE__.")";
                break;
            }

            // Tell COM about the location of pulic/private keys
            // Note: In successful case, LoadKeys() returns NULL in pHP5, but 0 (zero) in PHP4
            $errCode = @ $jnjCom->LoadKeys($privateKeyAbsPath, $passPhrase, $publicKeyAbsPath);
            if ($errCode){
                $errMsg = strip_tags($php_errormsg);
                $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTION_KEY;
                $this->errorMessage = 
                    "Unable to load encryption keys. ".
                    "Error [$errMsg] ".
                    "Private key [$privateKeyPath] ".
                    "Public key [$publicKeyPath] ".
                    "(".basename(__FILE__).":".__LINE__.")";
                break;
            }

            // Perform the encryption
            $cipher = @ $jnjCom->Encrypt($plainText, $siteId);
            if (! $cipher){
                $errMsg = strip_tags($php_errormsg);
                $errCode = HIT_ERR_UNABLE_TO_ENCRYPT;
                $this->errorMessage = 
                    "Unable to encrypt data. ".
                    "Error [$errMsg] ".
                    "(".basename(__FILE__).":".__LINE__.")";
                break;
            }
            
            unset($jnjCom);
        } while (false);
        
        ini_set('track_errors', $originalSetting);
        return $errCode;
    }




    //--------------------------------------------------------------------
    // NAME:    pkeDecrypt 
    // DESC:    Decrypt a message using Public Key Encryption (PKE)
    // PARAM:   plainText [out]
    //              Decrypted message
    //          cipher [in]
    //              Message to be decrypted.  Message must be in the 
    //              following format:
    //              <siteId>|<encrypted session key>|<encrypted content>
    //          privateKeyPath [in]
    //              Path of the (receipent's) private key file
    //          publicKeyPath [in]
    //              Path of the (sender's) public key file
    //          passPhrase [in]
    //              password for opening the private key
    // RETURN:  0 if operation is success
    //--------------------------------------------------------------------
    function pkeDecrypt(&$plainText, $cipher, $privateKeyPath, $publicKeyPath, $passPhrase)
    {
        global $php_errormsg;

        // Tell PHP to save error message into variable $php_errormsg 
        $originalSetting = ini_set('track_errors', 1);
        
        $plainText = '';
        $errCode = 0;

        $privateKeyAbsPath = realpath($privateKeyPath);
        $publicKeyAbsPath = realpath($publicKeyPath);

        do {
            //------------------------------------------------------
            // On Linux platform, we need to call a command-line program to do the decryption
			
            if ($this->platform == "linux"){

                // remove Return characters in the content; decryptor only supports one line input
                $oneLineInput = preg_replace("/\r|\n/", '', $cipher);

                // Put decryption command, settings (public/private key location), and data into an ASCII instruction file
                $cmd = "decrypt,$privateKeyAbsPath,$passPhrase,$publicKeyAbsPath,$oneLineInput";
                $errorFile = tempnam($this->tempDir, 'err');
                $instructionFile = tempnam($this->tempDir, 'enc');
                $hFile = fopen($instructionFile, "w");
                if( !$hFile ){
                    $this->errorMessage = "Unable to create temp file in directory [$this->tempDir]; make sure the directory is write-able. (".basename(__FILE__).":".__LINE__.")";
                    return HIT_ERR_CANNOT_CREATE_TEMP_FILE;
                }
                fwrite($hFile, $cmd);
                fclose($hFile);
                
                // Give the instruction file to decryptor
                $rtn = exec("{$this->niceCmd} \"{$this->encryptorProg}\" 2>$errorFile <$instructionFile", $response, $errCode);

                $hFile = fopen($errorFile, "r");
                $errMsg = "";
                while ($data = fread($hFile, 999)) {
                    $errMsg .= $data;        
                }
                fclose($hFile);
                    
                unlink($instructionFile);
                unlink($errorFile);

                // Parse the output from encryptor
                $plainText = trim(implode(" ", $response));

                // Check for error
                if (!$plainText || $errMsg){

                    if (! file_exists($this->encryptorProg)){
                        $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTOR;
                        $this->errorMessage = 
                            "Unable to locate jnjencryptor at [".HIT_LINUX_HMTG_ENCRYPTOR_PATH."]. ".
                            "(".basename(__FILE__).":".__LINE__.")";
                        break;
                    }
                    
                    if (! is_executable($this->encryptorProg)){
                        $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTOR;
                        $this->errorMessage = 
                            "Unable to execute jnjencryptor at [$this->encryptorProg]. ".
                            "Error [$errMsg]  ".
                            "Use 'chmod guo+rx' to change permission mode. ".
                            "(".basename(__FILE__).":".__LINE__.")";
                        break;
                    }
                    
                    if (! is_readable($privateKeyAbsPath) || ! is_readable($publicKeyAbsPath)){
                        $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTION_KEY;
                        $this->errorMessage = 
                            "Unable to load encryption keys. ".
                            "Error [$errMsg] ".
                            "Private key [$privateKeyPath] ".
                            "Public key [$publicKeyPath] ".
                            "(".basename(__FILE__).":".__LINE__.")";
                        break;
                    }

                    $errCode = HIT_ERR_UNABLE_TO_DECRYPT;
                    $this->errorMessage = 
                        "Unable to decrypt data. Error [$errMsg] ".
                        "(".basename(__FILE__).":".__LINE__.")";
                    break;
                }
               
                $errCode = 0;
                break;
            }

            //------------------------------------------------------
            // On Windows platform, we call COM to do the decryption

            // Make sure the COM component is installed
            $jnjCom = NULL;			
            $jnjCom = @ new COM("Hmtg.JnjEncryptor", NULL, CP_UTF8);
            if (is_null($jnjCom)){
                $errMsg = strip_tags($php_errormsg);
                $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTOR;
                $this->errorMessage = 
                    "Unable to load Hmtg.JnjEnecryptor COM object. ".
                    "Error [$errMsg] ".
                    "Use regsvr32 to register the COM object. ".
                    "(".basename(__FILE__).":".__LINE__.")";
                break;
            }

            // Tell COM about the location of pulic/private keys
            // Note: In successful case, LoadKeys() returns NULL in pHP5, but 0 (zero) in PHP4
            $errCode = @ $jnjCom->LoadKeys($privateKeyAbsPath, $passPhrase, $publicKeyAbsPath);
            if ($errCode){
                $errMsg = strip_tags($php_errormsg);
                $errCode = HIT_ERR_CANNOT_LOAD_ENCRYPTION_KEY;
                $this->errorMessage = 
                    "Unable to load encryption keys. ".
                    "Error [$errMsg] ".
                    "Private key [$privateKeyPath] ".
                    "Public key [$publicKeyPath] ".
                    "(".basename(__FILE__).":".__LINE__.")";
                break;
            }

            // Perform the decryption
            $plainText = @ $jnjCom->Decrypt($cipher);
            if (! $plainText ){
                $errMsg = strip_tags($php_errormsg);
                $errCode = HIT_ERR_UNABLE_TO_DECRYPT;
                $this->errorMessage = 
                    "Unable to decrypt data -- [$errMsg] ".
                    "(".basename(__FILE__).":".__LINE__.")";
                break;
            }
            
            unset($jnjCom);
        } while (false);
        
        ini_set('track_errors', $originalSetting);
        return $errCode;
    }





    //---------------------------------------------------------------------------
    // NAME:    getHexSha1
    // DESC:    Calculate the sha1 hash of a string
    // PARAM:   str [in]
    //            String to be encrypted
    // RETURN:  Encrypted string
    //---------------------------------------------------------------------------
    function getHexSha1( &$hash, $str ) {
        $hash = "";
        // Call PHP's built-in SHA1 function if it is available
        if( function_exists('sha1')){
            $hash = sha1($str);
            return;
        }

        // if not, we have to call OPENSSL program to get SHA1 value
        $tempFile = tempnam( $this->tempDir, "sha" );
        $hFile = @fopen( $tempFile, "w" );
        if( !$hFile ){
            $this->errorMessage = "Unable to create temp file in directory [$this->tempDir]; make sure the directory is writeable. (".basename(__FILE__).":".__LINE__.")";
            $errCode = HIT_ERR_CANNOT_CREATE_TEMP_FILE;
            return $errCode;
        }
        fwrite( $hFile, $str );
        fclose( $hFile );

        if( PLATFORM == "linux" ){
            $output = @shell_exec( "cat $tempFile | openssl sha1" );
        } else {
            $output = @shell_exec( "type $tempFile | \"{$this->opensslProg}\" sha1" );
        }
        $hash = preg_replace ( "/[^\w]/", "", $output );
        @ unlink( $tempFile );        
        return;
    }  


    //---------------------------------------------------------------------------
    // NAME:    getBase64Sha1
    // DESC:    Calculate the sha1 hash of a string in Base64 encoding
    //          Note: Base64 is not the same as Hexadecimal which is outputed by sha1()
    // PARAM:   $hash [out]
    //            Hash in base64 encoding
    //          plainText [in]
    //            String to be hashed
    // RETURN:  0 if operation is success
    //---------------------------------------------------------------------------
    function getBase64Sha1(&$hash, $plainText){
        $hash = "";
        
        if ($plainText == NULL || $plainText === ''){
            return;
        }

        $errCode = $this->getHexSha1($hexSha1, $plainText);
        if ($errCode){
            $this->errorMessage .= "\nUnable to perform SHA1 hashing. (".basename(__FILE__).":".__LINE__.")";
            return $errCode;
        }
        $binarySha1 = '';
        for ($i=0; $i<strlen($hexSha1); $i=$i+2){
            $binarySha1 .= chr(hexdec(substr($hexSha1,$i,2)));
        }

        $hash = base64_encode($binarySha1);
        return 0;
    }  
}

?>
